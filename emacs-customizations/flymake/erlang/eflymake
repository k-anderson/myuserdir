#!/usr/bin/env escript
-export([main/1]).

-record(state, {includes=[], paths=[], libs=get_erl_lib()}).

main([Target, File]) ->
    Paths = string:tokens(filename:dirname(File), "/"),
    BaseDir = find_project_base(Paths, ""),
    State = includes(BaseDir, #state{}),
    Defaults = "-W +warn_obsolete_guard +warn_unused_import +warn_shadow_vars +warn_export_vars +strong_validation +report +bin_opt_info",
    io:format("ERL_LIBS=\"~s\"; erlc ~s ~s ~s \"~s\"", [string:join(State#state.libs, ":")
                                                        ,string:join(State#state.includes, " ")
                                                        ,string:join(State#state.paths, " ")
                                                        ,Defaults
                                                        ,Target
                                                       ]).

get_erl_lib() ->
    case os:getenv("ERL_LIBS") of
        false -> [];
        ErlLibs ->
            string:tokens(ErlLibs, ":;")
    end.

includes(Dir, State) ->
    lists:foldl(fun(D, S) ->
                        case string:sub_string(D, string:rchr(D, $/) + 1) of
                            "include" ->
                                S#state{includes=[lists:flatten(["-I \"", Dir, "\""])
                                                  |S#state.includes
                                                 ]};
                            "ebin" ->
                                S#state{paths=[lists:flatten(["-pa \"", D, "\""])
                                               |S#state.paths
                                              ]};
                            Folder ->
                                includes(D, maybe_update_libs(Dir, Folder, S))
                        end
                end, State, get_sub_directories(Dir)).


maybe_update_libs(Dir, Folder, State) ->
    case string:sub_string(Dir, string:rchr(Dir, $/) + 1) =:= "lib"
        andalso re:run(Folder, "^.*-[0-9]+\.[0-9]+\.?[0-9]?$") =/= nomatch 
        andalso (not lists:member(Dir, State#state.libs))
    of
        false -> State;
        true ->
            State#state{libs=[lists:flatten(Dir)
                              |State#state.libs
                             ]}
    end.    

get_sub_directories(Dir) ->
    [D
     || D <- filelib:wildcard(lists:flatten([Dir, "/*"]))
            ,filelib:is_dir(D)
    ].

find_project_base([], Base) -> Base;
find_project_base([Path|Paths], Base) ->
    Dir = [Base, "/", Path],
    case is_std_erl_dir(Dir) of
        true -> Base;
        false ->
            find_project_base(Paths, Dir)
    end.

is_std_erl_dir(Dir) ->
    filelib:is_dir([Dir, "/src"])
        orelse filelib:is_dir([Dir, "/include"])
        orelse filelib:is_dir([Dir, "/ebin"])
        orelse filelib:is_file([Dir, "/rebar.config"])
        orelse filelib:is_file([Dir, "/Makefile"]).

